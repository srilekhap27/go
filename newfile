import React from 'react';
import { Provider } from 'react-redux';
import DocumentList from '../../../src/components/DocumentList';
import { render, fireEvent, waitFor } from '@testing-library/react';
import { documents } from '../../../src/api/dev/testData';
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from '../../../src/redux/documentSlice';
import { ERROR_MESSAGES } from '../../../src/utils/logger';

var mockDispatch = jest.fn();

jest.mock('../../../src/hooks/APIHook.js');
jest.mock('../../../src/api/Api', () => ({
    retrieveDocument: jest.fn(),
}));

import { retrieveDocument } from '../../../src/api/Api';

const action = {
    documentList: [documents, 200],
    filters: [],
    sorts: [],
    errors: [],
    resultCount: null,
    isMobile: false,
    documentError: '',
    loader: false,
    empty: false,
};

const createStore = (initialState = action) => {
    return configureStore({
        reducer: rootReducer,
        preloadedState: { action: initialState },
    });
};

describe('DocumentList component - Web View', () => {
    let store;

    beforeEach(() => {
        process.env.USAA_PLATFORM = 'standard';
        process.env.USAA_ENV = 'development';
        store = createStore();
        jest.clearAllMocks();
    });

    it('should call markDocumentCallback when response is undefined', async () => {
        retrieveDocument.mockResolvedValue(undefined);

        const { getByTestId } = render(
            <Provider store={store}>
                <DocumentList />
            </Provider>
        );

        fireEvent.click(getByTestId('readDoc-0'));

        await waitFor(() => {
            expect(mockDispatch).toHaveBeenCalledWith(
                expect.objectContaining({
                    type: 'errors/setError',
                    payload: ERROR_MESSAGES.VIEW_DOCUMENT_ERROR,
                })
            );
        });
    });

    it('should call markDocumentCallback when response array length is less than 2', async () => {
        retrieveDocument.mockResolvedValue([{}]); // Array with only one item

        const { getByTestId } = render(
            <Provider store={store}>
                <DocumentList />
            </Provider>
        );

        fireEvent.click(getByTestId('readDoc-0'));

        await waitFor(() => {
            expect(mockDispatch).toHaveBeenCalledWith(
                expect.objectContaining({
                    type: 'errors/setError',
                    payload: ERROR_MESSAGES.VIEW_DOCUMENT_ERROR,
                })
            );
        });
    });

    it('should NOT call markDocumentCallback when response is valid', async () => {
        retrieveDocument.mockResolvedValue(['content', 200, { 'content-type': 'application/pdf' }]);

        const { getByTestId } = render(
            <Provider store={store}>
                <DocumentList />
            </Provider>
        );

        fireEvent.click(getByTestId('readDoc-0'));

        await waitFor(() => {
            expect(mockDispatch).not.toHaveBeenCalledWith(
                expect.objectContaining({
                    type: 'errors/setError',
                    payload: ERROR_MESSAGES.VIEW_DOCUMENT_ERROR,
                })
            );
        });
    });
});
