// Package and Imports
package services

import (
    "fmt"
    "os"
    "time"

    "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
    "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
    "prodgitlab.usaa.com/grp-aws-my-documents/mydocs-cloud-commons/modules/logging/slog"
    "prodgitlab.usaa.com/grp-aws-my-documents/mydocs-cloud-commons/modules/models"
    "prodgitlab.usaa.com/grp-aws-my-documents/mydocs-cloud-commons/modules/repositories"
)

// Constants
const (
    PK        = "Pk"
    SK        = "Sk"
    PrtyIDKey = "PRTY_ID#"
    DateKey   = "DISP_DT#"
)

var tableName = os.Getenv("DOCUMENTS_TABLE")

type DocumentDBClient struct {
    DynamoDB repositories.Connection
}

func (d *DocumentDBClient) GetListByMember(item *models.Item, start *string, end *string, limit *int32, lastEvaluatedItem string, sortAscending *bool, tableItems interface{}) error {
    // Marshal PK
    partitionKey, err := attributevalue.Marshal(PrtyIDKey + item.Party.PartyID)
    if err != nil {
        slog.JSONLogger.With("error", err).Error("Error marshalling partitionKey " + PrtyIDKey + item.Party.PartyID)
        return err
    }

    // Pagination logic
    var lastKey map[string]types.AttributeValue
    if len(lastEvaluatedItem) > 0 {
        sortKey, err := attributevalue.Marshal(lastEvaluatedItem)
        if err != nil {
            slog.JSONLogger.With("error", err).Error("Error marshalling sortKey " + lastEvaluatedItem)
        }
        lastKey = map[string]types.AttributeValue{
            PK: partitionKey,
            SK: sortKey,
        }
    } else {
        lastKey = nil
    }

    // Date comparison and range
    if len(*start) > 0 && len(*end) > 0 {
        today := time.Now().Format(time.DateOnly)
        startDate, err := time.Parse(time.DateOnly, *start)
        if err != nil {
            slog.JSONLogger.With("error", err).Error("Start Display Date should be in YYYY-MM-DD format")
            return err
        }

        endDate, err := time.Parse(time.DateOnly, *end)
        if err != nil {
            slog.JSONLogger.With("error", err).Error("End Display Date should be in YYYY-MM-DD format")
            return err
        }

        if endDate.Before(today) {
            *end = FormatDate(today.Add(time.Hour*24), time.DateOnly)
        } else {
            endDate = endDate.Add(time.Hour * 24)
            *end = FormatDate(endDate, time.DateOnly)
        }

        // Create secondary key condition
        keyCondition = keyCondition.And(expression.Key(SK).Between(
            expression.Value(fmt.Sprintf("%s%s", DateKey, *start)),
            expression.Value(fmt.Sprintf("%s%s", DateKey, *end)),
        ))
    } else {
        displayDate := time.Now().Add(time.Hour * 24).Format(time.DateOnly)
        keyCondition = keyCondition.And(expression.Key(SK).LessThanEqual(expression.Value(fmt.Sprintf("%s%s", DateKey, displayDate))))
    }

    // Build select expression
    expr, err := BuildExpression(keyCondition, notExpired)
    if err != nil {
        slog.JSONLogger.With("error", err).Error("Failed to build expression")
        return err
    }

    err = d.DynamoDB.Query(&tableName, nil, expr, limit, lastKey, sortAscending, &tableItems)
    if err != nil {
        slog.JSONLogger.With("error", err).Error("Error getting items from Dynamo")
        return err
    }

    return nil
}
